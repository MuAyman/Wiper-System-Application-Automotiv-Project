var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"WiperSystem","ref":false,"files":[{"name":"WiperSystem.c","type":"source","group":"model","path":"G:\\ZC\\Practises\\Walid MBD course Project\\WiperSystem_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * WiperSystem.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"WiperSystem\".\r\n *\r\n * Model version              : 1.28\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Tue Aug 29 08:50:36 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"WiperSystem.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"WiperSystem_private.h\"\r\n#include <string.h>\r\n\r\n/* Block signals (default storage) */\r\nB_WiperSystem_T WiperSystem_B;\r\n\r\n/* Block states (default storage) */\r\nDW_WiperSystem_T WiperSystem_DW;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_WiperSystem_T WiperSystem_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_WiperSystem_T WiperSystem_M_;\r\nRT_MODEL_WiperSystem_T *const WiperSystem_M = &WiperSystem_M_;\r\nstatic void rate_scheduler(void);\r\nreal_T look1_binlg(real_T u0, const real_T bp0[], const real_T table[], uint32_T\r\n                   maxIndex)\r\n{\r\n  uint32_T bpIdx;\r\n  uint32_T iLeft;\r\n  uint32_T iRght;\r\n\r\n  /* Column-major Lookup 1-D\r\n     Search method: 'binary'\r\n     Use previous index: 'off'\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'on'\r\n   */\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'binary'\r\n     Use previous index: 'off'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'on'\r\n   */\r\n  /* Binary Search */\r\n  bpIdx = maxIndex >> 1U;\r\n  iLeft = 0U;\r\n  iRght = maxIndex;\r\n  while (iRght - iLeft > 1U) {\r\n    if (u0 < bp0[bpIdx]) {\r\n      iRght = bpIdx;\r\n    } else {\r\n      iLeft = bpIdx;\r\n    }\r\n\r\n    bpIdx = (iRght + iLeft) >> 1U;\r\n  }\r\n\r\n  real_T yL_0d0;\r\n\r\n  /* Column-major Interpolation 1-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Overflow mode: 'wrapping'\r\n   */\r\n  yL_0d0 = table[iLeft];\r\n  return (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]) * (table[iLeft + 1U]\r\n    - yL_0d0) + yL_0d0;\r\n}\r\n\r\n/*\r\n *         This function updates active task flag for each subrate.\r\n *         The function is called at model base rate, hence the\r\n *         generated code self-manages all its subrates.\r\n */\r\nstatic void rate_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (WiperSystem_M->Timing.TaskCounters.TID[1])++;\r\n  if ((WiperSystem_M->Timing.TaskCounters.TID[1]) > 99) {/* Sample time: [1.0s, 0.0s] */\r\n    WiperSystem_M->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S24>/not yet'\r\n *    '<S23>/not yet'\r\n *    '<S16>/not yet'\r\n *    '<S15>/not yet'\r\n *    '<S4>/Low'\r\n *    '<S4>/High'\r\n *    '<S4>/off'\r\n */\r\nvoid WiperSystem_notyet(real_T rtu_In1, real_T *rty_Out1)\r\n{\r\n  /* SignalConversion generated from: '<S27>/In1' */\r\n  *rty_Out1 = rtu_In1;\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S24>/reached'\r\n *    '<S23>/reached'\r\n *    '<S16>/reached'\r\n *    '<S15>/reached'\r\n */\r\nvoid WiperSystem_reached(real_T rtu_req, real_T *rty_DownPWM)\r\n{\r\n  /* SignalConversion generated from: '<S28>/req' */\r\n  *rty_DownPWM = rtu_req;\r\n}\r\n\r\n/*\r\n * System initialize for action system:\r\n *    '<S21>/StepUp'\r\n *    '<S13>/StepUp'\r\n */\r\nvoid WiperSystem_StepUp_Init(B_StepUp_WiperSystem_T *localB,\r\n  DW_StepUp_WiperSystem_T *localDW)\r\n{\r\n  /* InitializeConditions for Delay: '<S24>/Resettable Delay' */\r\n  localDW->icLoad = true;\r\n\r\n  /* SystemInitialize for Merge: '<S24>/Merge' */\r\n  localB->Merge = 0.0;\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S21>/StepUp'\r\n *    '<S13>/StepUp'\r\n */\r\nvoid WiperSystem_StepUp(real_T rtu_req, real_T rtu_prev, real_T *rty_UpPWM,\r\n  B_StepUp_WiperSystem_T *localB, DW_StepUp_WiperSystem_T *localDW)\r\n{\r\n  /* Delay: '<S24>/Resettable Delay' */\r\n  if (localDW->icLoad) {\r\n    localDW->ResettableDelay_DSTATE = rtu_prev;\r\n  }\r\n\r\n  /* If: '<S24>/If prev reaches req' incorporates:\r\n   *  Constant: '<S24>/Constant'\r\n   *  Delay: '<S24>/Resettable Delay'\r\n   *  Sum: '<S24>/Add1'\r\n   */\r\n  if (localDW->ResettableDelay_DSTATE + 0.01 < rtu_req) {\r\n    /* Outputs for IfAction SubSystem: '<S24>/not yet' incorporates:\r\n     *  ActionPort: '<S27>/Action Port'\r\n     */\r\n    WiperSystem_notyet(localDW->ResettableDelay_DSTATE + 0.01, &localB->Merge);\r\n\r\n    /* End of Outputs for SubSystem: '<S24>/not yet' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S24>/reached' incorporates:\r\n     *  ActionPort: '<S28>/Action Port'\r\n     */\r\n    WiperSystem_reached(rtu_req, &localB->Merge);\r\n\r\n    /* End of Outputs for SubSystem: '<S24>/reached' */\r\n  }\r\n\r\n  /* End of If: '<S24>/If prev reaches req' */\r\n\r\n  /* SignalConversion generated from: '<S24>/UpPWM' */\r\n  *rty_UpPWM = localB->Merge;\r\n\r\n  /* Update for Delay: '<S24>/Resettable Delay' */\r\n  localDW->icLoad = false;\r\n  localDW->ResettableDelay_DSTATE = localB->Merge;\r\n}\r\n\r\n/*\r\n * System initialize for action system:\r\n *    '<S21>/StepDown'\r\n *    '<S13>/StepDown'\r\n */\r\nvoid WiperSystem_StepDown_Init(B_StepDown_WiperSystem_T *localB,\r\n  DW_StepDown_WiperSystem_T *localDW)\r\n{\r\n  /* InitializeConditions for Delay: '<S23>/Resettable Delay' */\r\n  localDW->icLoad = true;\r\n\r\n  /* SystemInitialize for Merge: '<S23>/Merge' */\r\n  localB->Merge = 0.0;\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S21>/StepDown'\r\n *    '<S13>/StepDown'\r\n */\r\nvoid WiperSystem_StepDown(real_T rtu_req, real_T rtu_prev, real_T *rty_DownPWM,\r\n  B_StepDown_WiperSystem_T *localB, DW_StepDown_WiperSystem_T *localDW)\r\n{\r\n  /* Delay: '<S23>/Resettable Delay' */\r\n  if (localDW->icLoad) {\r\n    localDW->ResettableDelay_DSTATE = rtu_prev;\r\n  }\r\n\r\n  /* If: '<S23>/If prev reaches req' incorporates:\r\n   *  Constant: '<S23>/Constant'\r\n   *  Delay: '<S23>/Resettable Delay'\r\n   *  Sum: '<S23>/Add'\r\n   */\r\n  if (localDW->ResettableDelay_DSTATE - 0.01 > rtu_req) {\r\n    /* Outputs for IfAction SubSystem: '<S23>/not yet' incorporates:\r\n     *  ActionPort: '<S25>/Action Port'\r\n     */\r\n    WiperSystem_notyet(localDW->ResettableDelay_DSTATE - 0.01, &localB->Merge);\r\n\r\n    /* End of Outputs for SubSystem: '<S23>/not yet' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S23>/reached' incorporates:\r\n     *  ActionPort: '<S26>/Action Port'\r\n     */\r\n    WiperSystem_reached(rtu_req, &localB->Merge);\r\n\r\n    /* End of Outputs for SubSystem: '<S23>/reached' */\r\n  }\r\n\r\n  /* End of If: '<S23>/If prev reaches req' */\r\n\r\n  /* SignalConversion generated from: '<S23>/DownPWM' */\r\n  *rty_DownPWM = localB->Merge;\r\n\r\n  /* Update for Delay: '<S23>/Resettable Delay' */\r\n  localDW->icLoad = false;\r\n  localDW->ResettableDelay_DSTATE = localB->Merge;\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S21>/Keep'\r\n *    '<S13>/Keep'\r\n */\r\nvoid WiperSystem_Keep(real_T rtu_prev, real_T *rty_KeepPWM)\r\n{\r\n  /* SignalConversion generated from: '<S22>/prev' */\r\n  *rty_KeepPWM = rtu_prev;\r\n}\r\n\r\n/* Model step function */\r\nvoid WiperSystem_step(void)\r\n{\r\n  real_T rtb_Merge;\r\n  real_T rtb_Switch;\r\n  if (WiperSystem_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* FromWorkspace: '<S2>/FromWs' */\r\n    {\r\n      real_T *pDataValues = (real_T *) WiperSystem_DW.FromWs_PWORK.DataPtr;\r\n      real_T *pTimeValues = (real_T *) WiperSystem_DW.FromWs_PWORK.TimePtr;\r\n      int_T currTimeIndex = WiperSystem_DW.FromWs_IWORK.PrevIndex;\r\n      real_T t = (((WiperSystem_M->Timing.clockTick1+\r\n                    WiperSystem_M->Timing.clockTickH1* 4294967296.0)) * 1.0);\r\n      if (t >= pTimeValues[25]) {\r\n        {\r\n          int_T elIdx;\r\n          for (elIdx = 0; elIdx < 3; ++elIdx) {\r\n            (&WiperSystem_B.FromWs[0])[elIdx] = pDataValues[25];\r\n            pDataValues += 26;\r\n          }\r\n        }\r\n      } else {\r\n        /* Get index */\r\n        if (t <= pTimeValues[0]) {\r\n          currTimeIndex = 0;\r\n        } else if (t >= pTimeValues[25]) {\r\n          currTimeIndex = 24;\r\n        } else {\r\n          if (t < pTimeValues[currTimeIndex]) {\r\n            while (t < pTimeValues[currTimeIndex]) {\r\n              currTimeIndex--;\r\n            }\r\n          } else {\r\n            while (t >= pTimeValues[currTimeIndex + 1]) {\r\n              currTimeIndex++;\r\n            }\r\n          }\r\n        }\r\n\r\n        WiperSystem_DW.FromWs_IWORK.PrevIndex = currTimeIndex;\r\n\r\n        /* Post output */\r\n        {\r\n          real_T t1 = pTimeValues[currTimeIndex];\r\n          real_T t2 = pTimeValues[currTimeIndex + 1];\r\n          if (t1 == t2) {\r\n            if (t < t1) {\r\n              {\r\n                int_T elIdx;\r\n                for (elIdx = 0; elIdx < 3; ++elIdx) {\r\n                  (&WiperSystem_B.FromWs[0])[elIdx] = pDataValues[currTimeIndex];\r\n                  pDataValues += 26;\r\n                }\r\n              }\r\n            } else {\r\n              {\r\n                int_T elIdx;\r\n                for (elIdx = 0; elIdx < 3; ++elIdx) {\r\n                  (&WiperSystem_B.FromWs[0])[elIdx] = pDataValues[currTimeIndex\r\n                    + 1];\r\n                  pDataValues += 26;\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            real_T f1 = (t2 - t) / (t2 - t1);\r\n            real_T f2 = 1.0 - f1;\r\n            real_T d1;\r\n            real_T d2;\r\n            int_T TimeIndex = currTimeIndex;\r\n\r\n            {\r\n              int_T elIdx;\r\n              for (elIdx = 0; elIdx < 3; ++elIdx) {\r\n                d1 = pDataValues[TimeIndex];\r\n                d2 = pDataValues[TimeIndex + 1];\r\n                (&WiperSystem_B.FromWs[0])[elIdx] = (real_T) rtInterpolate(d1,\r\n                  d2, f1, f2);\r\n                pDataValues += 26;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* S-Function (fcgen): '<S1>/Ts = 10e-3' incorporates:\r\n   *  SubSystem: '<S1>/RainSnsrWiperMot'\r\n   */\r\n  /* SwitchCase: '<S4>/Switch Case' incorporates:\r\n   *  Constant: '<S4>/Constant2'\r\n   *  Constant: '<S4>/Constant3'\r\n   *  Constant: '<S4>/Constant4'\r\n   */\r\n  switch ((int32_T)WiperSystem_B.FromWs[0]) {\r\n   case 1:\r\n    /* Outputs for IfAction SubSystem: '<S4>/Auto' incorporates:\r\n     *  ActionPort: '<S5>/Action Port'\r\n     */\r\n    /* Lookup_n-D: '<S5>/1-D Lookup Table' */\r\n    rtb_Merge = look1_binlg(WiperSystem_B.FromWs[2],\r\n      WiperSystem_ConstP.uDLookupTable_bp01Data,\r\n      WiperSystem_ConstP.uDLookupTable_tableData, 7U);\r\n\r\n    /* Switch: '<S12>/Switch' incorporates:\r\n     *  DataTypeConversion: '<S12>/Data Type Conversion'\r\n     *  UnitDelay: '<S12>/Unit Delay'\r\n     */\r\n    if (rtb_Merge != 0.0) {\r\n      rtb_Switch = rtb_Merge;\r\n    } else {\r\n      rtb_Switch = WiperSystem_DW.UnitDelay_DSTATE;\r\n    }\r\n\r\n    /* End of Switch: '<S12>/Switch' */\r\n\r\n    /* Delay: '<S11>/Resettable Delay' */\r\n    if (WiperSystem_DW.icLoad_i) {\r\n      WiperSystem_DW.ResettableDelay_DSTATE_h = rtb_Switch;\r\n    }\r\n\r\n    /* If: '<S13>/If' incorporates:\r\n     *  Delay: '<S11>/Resettable Delay'\r\n     */\r\n    if (rtb_Switch > WiperSystem_DW.ResettableDelay_DSTATE_h) {\r\n      /* Outputs for IfAction SubSystem: '<S13>/StepUp' incorporates:\r\n       *  ActionPort: '<S16>/StepUp'\r\n       */\r\n      WiperSystem_StepUp(rtb_Switch, WiperSystem_DW.ResettableDelay_DSTATE_h,\r\n                         &WiperSystem_B.Merge, &WiperSystem_B.StepUp_p,\r\n                         &WiperSystem_DW.StepUp_p);\r\n\r\n      /* End of Outputs for SubSystem: '<S13>/StepUp' */\r\n    } else if (rtb_Switch < WiperSystem_DW.ResettableDelay_DSTATE_h) {\r\n      /* Outputs for IfAction SubSystem: '<S13>/StepDown' incorporates:\r\n       *  ActionPort: '<S15>/StepDown'\r\n       */\r\n      WiperSystem_StepDown(rtb_Switch, WiperSystem_DW.ResettableDelay_DSTATE_h,\r\n                           &WiperSystem_B.Merge, &WiperSystem_B.StepDown_p,\r\n                           &WiperSystem_DW.StepDown_p);\r\n\r\n      /* End of Outputs for SubSystem: '<S13>/StepDown' */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: '<S13>/Keep' incorporates:\r\n       *  ActionPort: '<S14>/Action Port'\r\n       */\r\n      WiperSystem_Keep(WiperSystem_DW.ResettableDelay_DSTATE_h,\r\n                       &WiperSystem_B.Merge);\r\n\r\n      /* End of Outputs for SubSystem: '<S13>/Keep' */\r\n    }\r\n\r\n    /* End of If: '<S13>/If' */\r\n\r\n    /* SignalConversion generated from: '<S5>/AutoPWM' */\r\n    rtb_Merge = WiperSystem_B.Merge;\r\n\r\n    /* Update for UnitDelay: '<S12>/Unit Delay' */\r\n    WiperSystem_DW.UnitDelay_DSTATE = rtb_Switch;\r\n\r\n    /* Update for Delay: '<S11>/Resettable Delay' */\r\n    WiperSystem_DW.icLoad_i = false;\r\n    WiperSystem_DW.ResettableDelay_DSTATE_h = WiperSystem_B.Merge;\r\n\r\n    /* End of Outputs for SubSystem: '<S4>/Auto' */\r\n    break;\r\n\r\n   case 2:\r\n    /* Outputs for IfAction SubSystem: '<S4>/Low' incorporates:\r\n     *  ActionPort: '<S7>/Action Port'\r\n     */\r\n    WiperSystem_notyet(0.4, &rtb_Merge);\r\n\r\n    /* End of Outputs for SubSystem: '<S4>/Low' */\r\n    break;\r\n\r\n   case 3:\r\n    /* Outputs for IfAction SubSystem: '<S4>/High' incorporates:\r\n     *  ActionPort: '<S6>/Action Port'\r\n     */\r\n    WiperSystem_notyet(0.7, &rtb_Merge);\r\n\r\n    /* End of Outputs for SubSystem: '<S4>/High' */\r\n    break;\r\n\r\n   default:\r\n    /* Outputs for IfAction SubSystem: '<S4>/off' incorporates:\r\n     *  ActionPort: '<S9>/Action Port'\r\n     */\r\n    WiperSystem_notyet(0.0, &rtb_Merge);\r\n\r\n    /* End of Outputs for SubSystem: '<S4>/off' */\r\n    break;\r\n  }\r\n\r\n  /* End of SwitchCase: '<S4>/Switch Case' */\r\n\r\n  /* Delay: '<S8>/Resettable Delay' */\r\n  if (WiperSystem_DW.icLoad) {\r\n    WiperSystem_DW.ResettableDelay_DSTATE = rtb_Merge;\r\n  }\r\n\r\n  /* If: '<S21>/If' incorporates:\r\n   *  Delay: '<S8>/Resettable Delay'\r\n   */\r\n  if (rtb_Merge > WiperSystem_DW.ResettableDelay_DSTATE) {\r\n    /* Outputs for IfAction SubSystem: '<S21>/StepUp' incorporates:\r\n     *  ActionPort: '<S24>/StepUp'\r\n     */\r\n    WiperSystem_StepUp(rtb_Merge, WiperSystem_DW.ResettableDelay_DSTATE,\r\n                       &rtb_Switch, &WiperSystem_B.StepUp,\r\n                       &WiperSystem_DW.StepUp);\r\n\r\n    /* End of Outputs for SubSystem: '<S21>/StepUp' */\r\n  } else if (rtb_Merge < WiperSystem_DW.ResettableDelay_DSTATE) {\r\n    /* Outputs for IfAction SubSystem: '<S21>/StepDown' incorporates:\r\n     *  ActionPort: '<S23>/StepDown'\r\n     */\r\n    WiperSystem_StepDown(rtb_Merge, WiperSystem_DW.ResettableDelay_DSTATE,\r\n                         &rtb_Switch, &WiperSystem_B.StepDown,\r\n                         &WiperSystem_DW.StepDown);\r\n\r\n    /* End of Outputs for SubSystem: '<S21>/StepDown' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S21>/Keep' incorporates:\r\n     *  ActionPort: '<S22>/Action Port'\r\n     */\r\n    WiperSystem_Keep(WiperSystem_DW.ResettableDelay_DSTATE, &rtb_Switch);\r\n\r\n    /* End of Outputs for SubSystem: '<S21>/Keep' */\r\n  }\r\n\r\n  /* End of If: '<S21>/If' */\r\n\r\n  /* Switch: '<S3>/Switch1' incorporates:\r\n   *  Constant: '<S3>/off'\r\n   */\r\n  if (WiperSystem_B.FromWs[1] > 0.0) {\r\n    rtb_Merge = 0.0;\r\n  } else {\r\n    rtb_Merge = rtb_Switch;\r\n  }\r\n\r\n  /* Outport: '<Root>/WiperMotPWMDutyCyc' incorporates:\r\n   *  Gain: '<S3>/MaxPWM'\r\n   *  Switch: '<S3>/Switch1'\r\n   */\r\n  WiperSystem_Y.WiperMotPWMDutyCyc = 255.0 * rtb_Merge;\r\n\r\n  /* Outport: '<Root>/WiperActv' incorporates:\r\n   *  Outport: '<Root>/WiperMotPWMDutyCyc'\r\n   *  Switch: '<S3>/Switch'\r\n   */\r\n  WiperSystem_Y.WiperActv = (WiperSystem_Y.WiperMotPWMDutyCyc > 0.0);\r\n\r\n  /* Update for Delay: '<S8>/Resettable Delay' */\r\n  WiperSystem_DW.icLoad = false;\r\n  WiperSystem_DW.ResettableDelay_DSTATE = rtb_Switch;\r\n\r\n  /* End of Outputs for S-Function (fcgen): '<S1>/Ts = 10e-3' */\r\n  if (WiperSystem_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* Update absolute timer for sample time: [1.0s, 0.0s] */\r\n    /* The \"clockTick1\" counts the number of times the code of this task has\r\n     * been executed. The resolution of this integer timer is 1.0, which is the step size\r\n     * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n     * application lifespan selected.\r\n     * Timer of this task consists of two 32 bit unsigned integers.\r\n     * The two integers represent the low bits Timing.clockTick1 and the high bits\r\n     * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\r\n     */\r\n    WiperSystem_M->Timing.clockTick1++;\r\n    if (!WiperSystem_M->Timing.clockTick1) {\r\n      WiperSystem_M->Timing.clockTickH1++;\r\n    }\r\n  }\r\n\r\n  rate_scheduler();\r\n}\r\n\r\n/* Model initialize function */\r\nvoid WiperSystem_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)WiperSystem_M, 0,\r\n                sizeof(RT_MODEL_WiperSystem_T));\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &WiperSystem_B), 0,\r\n                sizeof(B_WiperSystem_T));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&WiperSystem_DW, 0,\r\n                sizeof(DW_WiperSystem_T));\r\n\r\n  /* external outputs */\r\n  (void)memset(&WiperSystem_Y, 0, sizeof(ExtY_WiperSystem_T));\r\n\r\n  /* Start for FromWorkspace: '<S2>/FromWs' */\r\n  {\r\n    static real_T pTimeValues0[] = { 0.0, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0,\r\n      5.0, 5.0, 6.0, 6.0, 7.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 14.0,\r\n      15.0, 15.0, 16.0 } ;\r\n\r\n    static real_T pDataValues0[] = { 0.0, 0.0, 0.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0,\r\n      3.0, 3.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n      1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0,\r\n      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0,\r\n      3.0, 4.0, 5.0, 6.0, 7.0, 7.0, 7.0, 7.0, 7.0 } ;\r\n\r\n    WiperSystem_DW.FromWs_PWORK.TimePtr = (void *) pTimeValues0;\r\n    WiperSystem_DW.FromWs_PWORK.DataPtr = (void *) pDataValues0;\r\n    WiperSystem_DW.FromWs_IWORK.PrevIndex = 0;\r\n  }\r\n\r\n  /* SystemInitialize for S-Function (fcgen): '<S1>/Ts = 10e-3' incorporates:\r\n   *  SubSystem: '<S1>/RainSnsrWiperMot'\r\n   */\r\n  /* InitializeConditions for Delay: '<S8>/Resettable Delay' */\r\n  WiperSystem_DW.icLoad = true;\r\n\r\n  /* SystemInitialize for IfAction SubSystem: '<S4>/Auto' */\r\n  /* InitializeConditions for UnitDelay: '<S12>/Unit Delay' */\r\n  WiperSystem_DW.UnitDelay_DSTATE = 0.0;\r\n\r\n  /* InitializeConditions for Delay: '<S11>/Resettable Delay' */\r\n  WiperSystem_DW.icLoad_i = true;\r\n\r\n  /* SystemInitialize for IfAction SubSystem: '<S13>/StepUp' */\r\n  WiperSystem_StepUp_Init(&WiperSystem_B.StepUp_p, &WiperSystem_DW.StepUp_p);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S13>/StepUp' */\r\n\r\n  /* SystemInitialize for IfAction SubSystem: '<S13>/StepDown' */\r\n  WiperSystem_StepDown_Init(&WiperSystem_B.StepDown_p,\r\n    &WiperSystem_DW.StepDown_p);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S13>/StepDown' */\r\n\r\n  /* SystemInitialize for Merge: '<S13>/Merge' */\r\n  WiperSystem_B.Merge = 0.0;\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S4>/Auto' */\r\n\r\n  /* SystemInitialize for IfAction SubSystem: '<S21>/StepUp' */\r\n  WiperSystem_StepUp_Init(&WiperSystem_B.StepUp, &WiperSystem_DW.StepUp);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S21>/StepUp' */\r\n\r\n  /* SystemInitialize for IfAction SubSystem: '<S21>/StepDown' */\r\n  WiperSystem_StepDown_Init(&WiperSystem_B.StepDown, &WiperSystem_DW.StepDown);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S21>/StepDown' */\r\n\r\n  /* SystemInitialize for Outport: '<Root>/WiperMotPWMDutyCyc' incorporates:\r\n   *  Outport: '<S3>/WiperMotPWMDutyCyc'\r\n   */\r\n  WiperSystem_Y.WiperMotPWMDutyCyc = 0.0;\r\n\r\n  /* SystemInitialize for Outport: '<Root>/WiperActv' incorporates:\r\n   *  Outport: '<S3>/WiperActv'\r\n   */\r\n  WiperSystem_Y.WiperActv = 0.0;\r\n\r\n  /* End of SystemInitialize for S-Function (fcgen): '<S1>/Ts = 10e-3' */\r\n}\r\n\r\n/* Model terminate function */\r\nvoid WiperSystem_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n"},{"name":"WiperSystem.h","type":"header","group":"model","path":"G:\\ZC\\Practises\\Walid MBD course Project\\WiperSystem_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * WiperSystem.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"WiperSystem\".\r\n *\r\n * Model version              : 1.28\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Tue Aug 29 08:50:36 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_WiperSystem_h_\r\n#define RTW_HEADER_WiperSystem_h_\r\n#ifndef WiperSystem_COMMON_INCLUDES_\r\n#define WiperSystem_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* WiperSystem_COMMON_INCLUDES_ */\r\n\r\n#include \"WiperSystem_types.h\"\r\n#include <math.h>\r\n#include <string.h>\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals for system '<S21>/StepUp' */\r\ntypedef struct {\r\n  real_T Merge;                        /* '<S24>/Merge' */\r\n} B_StepUp_WiperSystem_T;\r\n\r\n/* Block states (default storage) for system '<S21>/StepUp' */\r\ntypedef struct {\r\n  real_T ResettableDelay_DSTATE;       /* '<S24>/Resettable Delay' */\r\n  boolean_T icLoad;                    /* '<S24>/Resettable Delay' */\r\n} DW_StepUp_WiperSystem_T;\r\n\r\n/* Block signals for system '<S21>/StepDown' */\r\ntypedef struct {\r\n  real_T Merge;                        /* '<S23>/Merge' */\r\n} B_StepDown_WiperSystem_T;\r\n\r\n/* Block states (default storage) for system '<S21>/StepDown' */\r\ntypedef struct {\r\n  real_T ResettableDelay_DSTATE;       /* '<S23>/Resettable Delay' */\r\n  boolean_T icLoad;                    /* '<S23>/Resettable Delay' */\r\n} DW_StepDown_WiperSystem_T;\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T FromWs[3];                    /* '<S2>/FromWs' */\r\n  real_T Merge;                        /* '<S13>/Merge' */\r\n  B_StepDown_WiperSystem_T StepDown_p; /* '<S13>/StepDown' */\r\n  B_StepUp_WiperSystem_T StepUp_p;     /* '<S13>/StepUp' */\r\n  B_StepDown_WiperSystem_T StepDown;   /* '<S21>/StepDown' */\r\n  B_StepUp_WiperSystem_T StepUp;       /* '<S21>/StepUp' */\r\n} B_WiperSystem_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T ResettableDelay_DSTATE;       /* '<S8>/Resettable Delay' */\r\n  real_T UnitDelay_DSTATE;             /* '<S12>/Unit Delay' */\r\n  real_T ResettableDelay_DSTATE_h;     /* '<S11>/Resettable Delay' */\r\n  struct {\r\n    void *TimePtr;\r\n    void *DataPtr;\r\n    void *RSimInfoPtr;\r\n  } FromWs_PWORK;                      /* '<S2>/FromWs' */\r\n\r\n  struct {\r\n    int_T PrevIndex;\r\n  } FromWs_IWORK;                      /* '<S2>/FromWs' */\r\n\r\n  boolean_T icLoad;                    /* '<S8>/Resettable Delay' */\r\n  boolean_T icLoad_i;                  /* '<S11>/Resettable Delay' */\r\n  DW_StepDown_WiperSystem_T StepDown_p;/* '<S13>/StepDown' */\r\n  DW_StepUp_WiperSystem_T StepUp_p;    /* '<S13>/StepUp' */\r\n  DW_StepDown_WiperSystem_T StepDown;  /* '<S21>/StepDown' */\r\n  DW_StepUp_WiperSystem_T StepUp;      /* '<S21>/StepUp' */\r\n} DW_WiperSystem_T;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Expression: [0 0.40 0.45 0.50 0.55 0.60 0.65 0.70]\r\n   * Referenced by: '<S5>/1-D Lookup Table'\r\n   */\r\n  real_T uDLookupTable_tableData[8];\r\n\r\n  /* Expression: [0 1 2 3 4 5 6 7]\r\n   * Referenced by: '<S5>/1-D Lookup Table'\r\n   */\r\n  real_T uDLookupTable_bp01Data[8];\r\n} ConstP_WiperSystem_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T WiperMotPWMDutyCyc;           /* '<Root>/WiperMotPWMDutyCyc' */\r\n  real_T WiperActv;                    /* '<Root>/WiperActv' */\r\n} ExtY_WiperSystem_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_WiperSystem_T {\r\n  const char_T *errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick1;\r\n    uint32_T clockTickH1;\r\n    struct {\r\n      uint8_T TID[2];\r\n    } TaskCounters;\r\n  } Timing;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_WiperSystem_T WiperSystem_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_WiperSystem_T WiperSystem_DW;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_WiperSystem_T WiperSystem_Y;\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstP_WiperSystem_T WiperSystem_ConstP;\r\n\r\n/* Model entry point functions */\r\nextern void WiperSystem_initialize(void);\r\nextern void WiperSystem_step(void);\r\nextern void WiperSystem_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_WiperSystem_T *const WiperSystem_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'WiperSystem'\r\n * '<S1>'   : 'WiperSystem/Model'\r\n * '<S2>'   : 'WiperSystem/Signal Builder'\r\n * '<S3>'   : 'WiperSystem/Model/RainSnsrWiperMot'\r\n * '<S4>'   : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode'\r\n * '<S5>'   : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto'\r\n * '<S6>'   : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/High'\r\n * '<S7>'   : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Low'\r\n * '<S8>'   : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing'\r\n * '<S9>'   : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/off'\r\n * '<S10>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Signal Sample and Hold'\r\n * '<S11>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing'\r\n * '<S12>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Signal Sample and Hold/Discrete'\r\n * '<S13>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing/Change Speed'\r\n * '<S14>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing/Change Speed/Keep'\r\n * '<S15>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing/Change Speed/StepDown'\r\n * '<S16>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing/Change Speed/StepUp'\r\n * '<S17>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing/Change Speed/StepDown/not yet'\r\n * '<S18>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing/Change Speed/StepDown/reached'\r\n * '<S19>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing/Change Speed/StepUp/not yet'\r\n * '<S20>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Auto/Smoothing/Change Speed/StepUp/reached'\r\n * '<S21>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing/Change Speed'\r\n * '<S22>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing/Change Speed/Keep'\r\n * '<S23>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing/Change Speed/StepDown'\r\n * '<S24>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing/Change Speed/StepUp'\r\n * '<S25>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing/Change Speed/StepDown/not yet'\r\n * '<S26>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing/Change Speed/StepDown/reached'\r\n * '<S27>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing/Change Speed/StepUp/not yet'\r\n * '<S28>'  : 'WiperSystem/Model/RainSnsrWiperMot/Select Mode/Smoothing/Change Speed/StepUp/reached'\r\n */\r\n#endif                                 /* RTW_HEADER_WiperSystem_h_ */\r\n"},{"name":"WiperSystem_private.h","type":"header","group":"model","path":"G:\\ZC\\Practises\\Walid MBD course Project\\WiperSystem_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * WiperSystem_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"WiperSystem\".\r\n *\r\n * Model version              : 1.28\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Tue Aug 29 08:50:36 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_WiperSystem_private_h_\r\n#define RTW_HEADER_WiperSystem_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#include \"WiperSystem.h\"\r\n#include \"WiperSystem_types.h\"\r\n\r\n/* Used by FromWorkspace Block: '<S2>/FromWs' */\r\n#ifndef rtInterpolate\r\n# define rtInterpolate(v1,v2,f1,f2)    (((v1)==(v2))?((double)(v1)): (((f1)*((double)(v1)))+((f2)*((double)(v2)))))\r\n#endif\r\n\r\n#ifndef rtRound\r\n# define rtRound(v)                    ( ((v) >= 0) ? floor((v) + 0.5) : ceil((v) - 0.5) )\r\n#endif\r\n\r\nextern real_T look1_binlg(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T maxIndex);\r\nextern void WiperSystem_notyet(real_T rtu_In1, real_T *rty_Out1);\r\nextern void WiperSystem_reached(real_T rtu_req, real_T *rty_DownPWM);\r\nextern void WiperSystem_StepUp_Init(B_StepUp_WiperSystem_T *localB,\r\n  DW_StepUp_WiperSystem_T *localDW);\r\nextern void WiperSystem_StepUp(real_T rtu_req, real_T rtu_prev, real_T\r\n  *rty_UpPWM, B_StepUp_WiperSystem_T *localB, DW_StepUp_WiperSystem_T *localDW);\r\nextern void WiperSystem_StepDown_Init(B_StepDown_WiperSystem_T *localB,\r\n  DW_StepDown_WiperSystem_T *localDW);\r\nextern void WiperSystem_StepDown(real_T rtu_req, real_T rtu_prev, real_T\r\n  *rty_DownPWM, B_StepDown_WiperSystem_T *localB, DW_StepDown_WiperSystem_T\r\n  *localDW);\r\nextern void WiperSystem_Keep(real_T rtu_prev, real_T *rty_KeepPWM);\r\n\r\n#endif                                 /* RTW_HEADER_WiperSystem_private_h_ */\r\n"},{"name":"WiperSystem_types.h","type":"header","group":"model","path":"G:\\ZC\\Practises\\Walid MBD course Project\\WiperSystem_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * WiperSystem_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"WiperSystem\".\r\n *\r\n * Model version              : 1.28\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Tue Aug 29 08:50:36 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_WiperSystem_types_h_\r\n#define RTW_HEADER_WiperSystem_types_h_\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_WiperSystem_T RT_MODEL_WiperSystem_T;\r\n\r\n#endif                                 /* RTW_HEADER_WiperSystem_types_h_ */\r\n"},{"name":"WiperSystem_data.c","type":"source","group":"data","path":"G:\\ZC\\Practises\\Walid MBD course Project\\WiperSystem_grt_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * WiperSystem_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"WiperSystem\".\r\n *\r\n * Model version              : 1.28\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Tue Aug 29 08:50:36 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"WiperSystem.h\"\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstP_WiperSystem_T WiperSystem_ConstP = {\r\n  /* Expression: [0 0.40 0.45 0.50 0.55 0.60 0.65 0.70]\r\n   * Referenced by: '<S5>/1-D Lookup Table'\r\n   */\r\n  { 0.0, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7 },\r\n\r\n  /* Expression: [0 1 2 3 4 5 6 7]\r\n   * Referenced by: '<S5>/1-D Lookup Table'\r\n   */\r\n  { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 }\r\n};\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"G:\\ZC\\Practises\\Walid MBD course Project\\WiperSystem_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"WiperSystem\".\r\n *\r\n * Model version              : 1.28\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Tue Aug 29 08:50:36 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long int long_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} int64m_T;\r\n\r\ntypedef struct {\r\n  int64m_T re;\r\n  int64m_T im;\r\n} cint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} uint64m_T;\r\n\r\ntypedef struct {\r\n  uint64m_T re;\r\n  uint64m_T im;\r\n} cuint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} int96m_T;\r\n\r\ntypedef struct {\r\n  int96m_T re;\r\n  int96m_T im;\r\n} cint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} uint96m_T;\r\n\r\ntypedef struct {\r\n  uint96m_T re;\r\n  uint96m_T im;\r\n} cuint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} int160m_T;\r\n\r\ntypedef struct {\r\n  int160m_T re;\r\n  int160m_T im;\r\n} cint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} uint160m_T;\r\n\r\ntypedef struct {\r\n  uint160m_T re;\r\n  uint160m_T im;\r\n} cuint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} int224m_T;\r\n\r\ntypedef struct {\r\n  int224m_T re;\r\n  int224m_T im;\r\n} cint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} uint224m_T;\r\n\r\ntypedef struct {\r\n  uint224m_T re;\r\n  uint224m_T im;\r\n} cuint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} int288m_T;\r\n\r\ntypedef struct {\r\n  int288m_T re;\r\n  int288m_T im;\r\n} cint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} uint288m_T;\r\n\r\ntypedef struct {\r\n  uint288m_T re;\r\n  uint288m_T im;\r\n} cuint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} int352m_T;\r\n\r\ntypedef struct {\r\n  int352m_T re;\r\n  int352m_T im;\r\n} cint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} uint352m_T;\r\n\r\ntypedef struct {\r\n  uint352m_T re;\r\n  uint352m_T im;\r\n} cuint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} int416m_T;\r\n\r\ntypedef struct {\r\n  int416m_T re;\r\n  int416m_T im;\r\n} cint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} uint416m_T;\r\n\r\ntypedef struct {\r\n  uint416m_T re;\r\n  uint416m_T im;\r\n} cuint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} int480m_T;\r\n\r\ntypedef struct {\r\n  int480m_T re;\r\n  int480m_T im;\r\n} cint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} uint480m_T;\r\n\r\ntypedef struct {\r\n  uint480m_T re;\r\n  uint480m_T im;\r\n} cuint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} int544m_T;\r\n\r\ntypedef struct {\r\n  int544m_T re;\r\n  int544m_T im;\r\n} cint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} uint544m_T;\r\n\r\ntypedef struct {\r\n  uint544m_T re;\r\n  uint544m_T im;\r\n} cuint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} int608m_T;\r\n\r\ntypedef struct {\r\n  int608m_T re;\r\n  int608m_T im;\r\n} cint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} uint608m_T;\r\n\r\ntypedef struct {\r\n  uint608m_T re;\r\n  uint608m_T im;\r\n} cuint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} int672m_T;\r\n\r\ntypedef struct {\r\n  int672m_T re;\r\n  int672m_T im;\r\n} cint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} uint672m_T;\r\n\r\ntypedef struct {\r\n  uint672m_T re;\r\n  uint672m_T im;\r\n} cuint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} int736m_T;\r\n\r\ntypedef struct {\r\n  int736m_T re;\r\n  int736m_T im;\r\n} cint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} uint736m_T;\r\n\r\ntypedef struct {\r\n  uint736m_T re;\r\n  uint736m_T im;\r\n} cuint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} int800m_T;\r\n\r\ntypedef struct {\r\n  int800m_T re;\r\n  int800m_T im;\r\n} cint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} uint800m_T;\r\n\r\ntypedef struct {\r\n  uint800m_T re;\r\n  uint800m_T im;\r\n} cuint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} int864m_T;\r\n\r\ntypedef struct {\r\n  int864m_T re;\r\n  int864m_T im;\r\n} cint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} uint864m_T;\r\n\r\ntypedef struct {\r\n  uint864m_T re;\r\n  uint864m_T im;\r\n} cuint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} int928m_T;\r\n\r\ntypedef struct {\r\n  int928m_T re;\r\n  int928m_T im;\r\n} cint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} uint928m_T;\r\n\r\ntypedef struct {\r\n  uint928m_T re;\r\n  uint928m_T im;\r\n} cuint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} int992m_T;\r\n\r\ntypedef struct {\r\n  int992m_T re;\r\n  int992m_T im;\r\n} cint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} uint992m_T;\r\n\r\ntypedef struct {\r\n  uint992m_T re;\r\n  uint992m_T im;\r\n} cuint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} int1056m_T;\r\n\r\ntypedef struct {\r\n  int1056m_T re;\r\n  int1056m_T im;\r\n} cint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} uint1056m_T;\r\n\r\ntypedef struct {\r\n  uint1056m_T re;\r\n  uint1056m_T im;\r\n} cuint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} int1120m_T;\r\n\r\ntypedef struct {\r\n  int1120m_T re;\r\n  int1120m_T im;\r\n} cint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} uint1120m_T;\r\n\r\ntypedef struct {\r\n  uint1120m_T re;\r\n  uint1120m_T im;\r\n} cuint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} int1184m_T;\r\n\r\ntypedef struct {\r\n  int1184m_T re;\r\n  int1184m_T im;\r\n} cint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} uint1184m_T;\r\n\r\ntypedef struct {\r\n  uint1184m_T re;\r\n  uint1184m_T im;\r\n} cuint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} int1248m_T;\r\n\r\ntypedef struct {\r\n  int1248m_T re;\r\n  int1248m_T im;\r\n} cint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} uint1248m_T;\r\n\r\ntypedef struct {\r\n  uint1248m_T re;\r\n  uint1248m_T im;\r\n} cuint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} int1312m_T;\r\n\r\ntypedef struct {\r\n  int1312m_T re;\r\n  int1312m_T im;\r\n} cint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} uint1312m_T;\r\n\r\ntypedef struct {\r\n  uint1312m_T re;\r\n  uint1312m_T im;\r\n} cuint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} int1376m_T;\r\n\r\ntypedef struct {\r\n  int1376m_T re;\r\n  int1376m_T im;\r\n} cint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} uint1376m_T;\r\n\r\ntypedef struct {\r\n  uint1376m_T re;\r\n  uint1376m_T im;\r\n} cuint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} int1440m_T;\r\n\r\ntypedef struct {\r\n  int1440m_T re;\r\n  int1440m_T im;\r\n} cint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} uint1440m_T;\r\n\r\ntypedef struct {\r\n  uint1440m_T re;\r\n  uint1440m_T im;\r\n} cuint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} int1504m_T;\r\n\r\ntypedef struct {\r\n  int1504m_T re;\r\n  int1504m_T im;\r\n} cint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} uint1504m_T;\r\n\r\ntypedef struct {\r\n  uint1504m_T re;\r\n  uint1504m_T im;\r\n} cuint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} int1568m_T;\r\n\r\ntypedef struct {\r\n  int1568m_T re;\r\n  int1568m_T im;\r\n} cint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} uint1568m_T;\r\n\r\ntypedef struct {\r\n  uint1568m_T re;\r\n  uint1568m_T im;\r\n} cuint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} int1632m_T;\r\n\r\ntypedef struct {\r\n  int1632m_T re;\r\n  int1632m_T im;\r\n} cint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} uint1632m_T;\r\n\r\ntypedef struct {\r\n  uint1632m_T re;\r\n  uint1632m_T im;\r\n} cuint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} int1696m_T;\r\n\r\ntypedef struct {\r\n  int1696m_T re;\r\n  int1696m_T im;\r\n} cint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} uint1696m_T;\r\n\r\ntypedef struct {\r\n  uint1696m_T re;\r\n  uint1696m_T im;\r\n} cuint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} int1760m_T;\r\n\r\ntypedef struct {\r\n  int1760m_T re;\r\n  int1760m_T im;\r\n} cint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} uint1760m_T;\r\n\r\ntypedef struct {\r\n  uint1760m_T re;\r\n  uint1760m_T im;\r\n} cuint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} int1824m_T;\r\n\r\ntypedef struct {\r\n  int1824m_T re;\r\n  int1824m_T im;\r\n} cint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} uint1824m_T;\r\n\r\ntypedef struct {\r\n  uint1824m_T re;\r\n  uint1824m_T im;\r\n} cuint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} int1888m_T;\r\n\r\ntypedef struct {\r\n  int1888m_T re;\r\n  int1888m_T im;\r\n} cint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} uint1888m_T;\r\n\r\ntypedef struct {\r\n  uint1888m_T re;\r\n  uint1888m_T im;\r\n} cuint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} int1952m_T;\r\n\r\ntypedef struct {\r\n  int1952m_T re;\r\n  int1952m_T im;\r\n} cint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} uint1952m_T;\r\n\r\ntypedef struct {\r\n  uint1952m_T re;\r\n  uint1952m_T im;\r\n} cuint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} int2016m_T;\r\n\r\ntypedef struct {\r\n  int2016m_T re;\r\n  int2016m_T im;\r\n} cint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} uint2016m_T;\r\n\r\ntypedef struct {\r\n  uint2016m_T re;\r\n  uint2016m_T im;\r\n} cuint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"G:\\ZC\\Practises\\Walid MBD course Project\\WiperSystem_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"WiperSystem\".\r\n *\r\n * Model version              : 1.28\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Tue Aug 29 08:50:36 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"G:\\ZC\\Practises\\Walid MBD course Project\\WiperSystem_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"WiperSystem\".\r\n *\r\n * Model version              : 1.28\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Tue Aug 29 08:50:36 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"WiperSystem.h\"\r\n#define GRTINTERFACE                   0\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":false,"showJustificationLinks":false,"showProfilingInfo":false,"showTaskSummary":false}};